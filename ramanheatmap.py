# Creates a matrix of tuples (magnetic field, radial frequency, power spectral density) generated by TEBD
# Outputs matrix to CSV
# Sami Hakani
# GaTech Physics, 2022

import sys
import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter
from scipy.interpolate import griddata
#import seaborn as sns

class Plotter():
    def __init__(self, n, H_str, R_str, removeElastic=True): # initialize class
        self.n = n
        self.H_str = H_str
        self.R_str = R_str
        self.dt = 0.0628 # standardized for my TEBD runs so far, 24 Oct 2022

        self.df = None # empty dataframe for all data
        self.df_buffer = None # empty dataframe of buffer
        self.removeElastic = removeElastic

        self.getharr()

    def getharr(self): # generates array of fields for all csv files in current directory
        files = [f for f in os.listdir(os.curdir) if '{}-{}-n={}-'.format(self.H_str, self.R_str, self.n) in f]
        '''
        files = [f for f in os.listdir(os.curdir) if 'rz' in f]
        files = [f for f in files if self.H_str in f]
        files = [f for f in files if self.R_str in f]
        files = [f for f in files if 'n={}-'.format(self.n) in f]
        '''
        files = [float(f.split('-')[3][3:]) for f in files]
        files = list(set(files))
        self.harr = sorted(files)

    def parseFilename(self, h): # parses field strength to TEBD data's filename
        filename = "{}-{}-n={}-hz={:.2f}-rz=0.00.csv".format(self.H_str, self.R_str, self.n, h)
        return filename

    def loadTEBD(self, h): # loads a single trace into buffer
        _ = self.parseFilename(h)
        self.df_buffer = pd.read_csv(_, names=['t', 'corr_RR'])

    def sort_data(self, arr1, arr2): # sorts arr2 based on ordering of arr1
        zipped_lists = zip(arr1, arr2)
        sorted_zipped = sorted(zipped_lists)
        arr1_s = sorted(arr1)
        arr2_s = [el for _, el in sorted_zipped]
        return np.array(arr1_s), np.array(arr2_s)

    def FFT(self, h): # fourier transforms data in buffer
        t, i = self.df_buffer['t'].to_numpy(), self.df_buffer['corr_RR'].to_numpy() # typecast to numpy array
        i_fft = np.fft.fft(i) / len(i)
        freq = np.fft.fftfreq(np.size(i_fft), d=self.dt)

        freq, i_fft = self.sort_data((-2*np.pi)*freq, np.abs(i_fft)**2)

        self.df_buffer = self.df_buffer.rename(columns={'t': 'h', 'corr_RR':'freq'})

        self.df_buffer['h'] = h*np.ones(freq.shape)
        self.df_buffer['freq'] = freq
        self.df_buffer['i'] = i_fft


    def storeTEBD(self, h): # imports Fourier transformed data into dataframe
        self.loadTEBD(h)
        self.FFT(h)
        if type(self.df) == type(None): # data is empty
            self.df = self.df_buffer.copy() # copies buffer to main dataframe
        else:
            self.df = pd.concat([self.df, self.df_buffer])

    def importTEBD(self):
        for h in self.harr:
            self.storeTEBD(h)

    def exportTEBD(self):
        if type(self.df) == type(None):
            print('Error: no data imported')
        else:
            _ = '{}-{}-n={}.csv'.format(self.H_str, self.R_str, self.n)
            self.df.to_csv(_)

    def plot(self, logplot=False): # plots current dataframe
        l = self.df['h'].shape[0]

        x = np.unique(self.df['h'].values)
        y = np.unique(self.df['freq'].values)
        z = self.df['i'].values
        if self.removeElastic:
            for j in range(len(y)):
                if y[j] == 0:
                    z[j] = 0

        z = np.reshape(self.df['i'].values, (len(self.harr), int(l/len(self.harr))))
        zlog = np.reshape(np.log(self.df['i'].values), (len(self.harr), int(l/len(self.harr))))
        
        extent = (min(y), max(y), min(x), max(x))

        if logplot:
            #plt.imshow(np.flip(zlog, axis=0), cmap='coolwarm', interpolation='none', aspect='auto', extent=extent) 
            plt.imshow(np.flip(zlog, axis=0), cmap='coolwarm', interpolation='none', aspect='auto') 
            plt.colorbar(label='log Intensity (a. u.)')
        else:
            #plt.imshow(np.flip(z, axis=0), cmap='coolwarm', interpolation='none', aspect='auto', extent=extent) 
            plt.imshow(np.flip(z, axis=0), cmap='coolwarm', interpolation='none', aspect='auto') 
            plt.colorbar(label='Intensity (a. u.)')
        #plt.ylim(0, .4)
        plt.xlim(4990, 5200)
        plt.ylabel('$h_z$')
        plt.xlabel('$\omega$')
        if self.removeElastic:
            plt.title('TEBD Magneto-Raman Response ({}, {}, n = {}; inelastic only)'.format(self.H_str, self.R_str, self.n))
        else:
            plt.title('TEBD Magneto-Raman Response ({}, {}, n = {})'.format(self.H_str, self.R_str, self.n))

        #plt.gca().get_xaxis().set_major_formatter(FuncFormatter(lambda x, p: format(round(float(0.010004071637975906*x - 50.01535565380693), 5), ','))) 
        plt.gca().get_xaxis().set_major_formatter(FuncFormatter(lambda x, p: format(round(float(-50.01535565380693 + 0.010005072145190424*x), 5), ','))) 

        plt.yticks(range(len(np.unique(x))), np.unique(x)[::-1], size='small')


        plt.show()

    def plot2(self):
        x, y, z = np.unique(self.df['h'].values), np.unique(self.df['freq'].values), self.df['i'].values

        # create grid
        xi = np.linspace(min(x), max(x), len(z))
        yi = np.linspace(min(y), max(y), len(z))
        zi = griddata((x,y), z, (xi[None,:], yi[:,None]), method='cubic')
        CS = plt.contourf(xi,yi,zi,15,cmap=plt.cm.jet)
        plt.colorbar() # draw colorbar
        plt.show()


n, H, R = int(sys.argv[1]), sys.argv[2], sys.argv[3]
myPlotter = Plotter(n, H, R, removeElastic=False)
myPlotter.importTEBD()
myPlotter.exportTEBD()
#myPlotter.plot(logplot=False)
#myPlotter.plot2()


'''

narr = np.array([20, 40, 60, 80])
hDarr = np.array([.85, .5, .3, .45])
hD31arr = np.array([.25, .45, .1, .13])
hD32arr = np.array([.9, .825, .4, .33])

plt.scatter(narr, hDarr)
plt.scatter(narr, hD31arr)
plt.scatter(narr, hD32arr)

plt.show()
'''
